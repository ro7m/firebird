import { useState, useEffect } from 'react';

const useSpeechRecognition = (activeTab) => {
  const [recognition, setRecognition] = useState(null);
  const [transcripts, setTranscripts] = useState({});
  const [isRecording, setIsRecording] = useState(false);

  useEffect(() => {
    if ('webkitSpeechRecognition' in window) {
      const recognition = new window.webkitSpeechRecognition();
      
      recognition.continuous = true;
      recognition.interimResults = true;
      
      recognition.onresult = (event) => {
        // Debug each result
        for (let i = 0; i < event.results.length; i++) {
          const result = event.results[i];
          console.log(`Result ${i}:`, {
            transcript: result[0].transcript,
            confidence: result[0].confidence,
            isFinal: result.isFinal
          });
        }

        // Get the latest result
        const lastResult = event.results[event.results.length - 1];
        const transcript = lastResult[0].transcript;
        
        // Update based on whether it's final or not
        if (lastResult.isFinal) {
          console.log('FINAL RESULT:', transcript);
          setTranscripts(prev => {
            const currentText = prev[activeTab] || '';
            return {
              ...prev,
              [activeTab]: currentText + ' ' + transcript.trim()
            };
          });
        } else {
          console.log('INTERIM RESULT:', transcript);
          // For interim results, show the current recognition
          setTranscripts(prev => ({
            ...prev,
            [activeTab]: (prev[activeTab] || '').trimEnd() + ' ' + transcript.trim()
          }));
        }
      };

      recognition.onstart = () => {
        console.log('Speech recognition started');
      };

      recognition.onend = () => {
        console.log('Speech recognition ended');
        if (isRecording) {
          recognition.start();
        }
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        setIsRecording(false);
      };

      setRecognition(recognition);
    }
  }, [activeTab, isRecording]);

  const startRecording = () => {
    if (recognition) {
      // Clear the transcript when starting new recording
      setTranscripts(prev => ({
        ...prev,
        [activeTab]: ''
      }));
      recognition.start();
      setIsRecording(true);
    }
  };

  const stopRecording = () => {
    if (recognition) {
      recognition.stop();
      setIsRecording(false);
    }
  };

  return {
    isRecording,
    transcripts,
    startRecording,
    stopRecording
  };
};

export default useSpeechRecognition;
